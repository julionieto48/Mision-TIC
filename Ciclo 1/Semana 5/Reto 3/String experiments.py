# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WYHYbsQVexGKwJPQJC8O-Upb1vrMWP7o
"""

#reto 3 

def contadorTiquetes(cadena):
  counter  = 0
  patronBuscar = "A"


  for i in cadena:
    if i == patronBuscar:
      counter += 1

   
  print(counter)


ingreso  = "AASDASDDAA AAAAAAERQREQREQRAAAAREWQRWERAAA"
contadorTiquetes(ingreso)

# como solucionar cuando no es una sola letra ???

#reto 3 


def contadorTiquetes(cadena):
  
  patronBuscar = "AA"

  #encontrar las longitudes
  sLen = len(cadena) ;  patronLen = len(patronBuscar)
  print(sLen - patronLen)
  
  i =0
  counter = 0 
  while i <= sLen - patronLen:
    if cadena[i] == patronBuscar[0]:  
      # se recorre el string ingresado y si una de estas letras coincide con la primer letra del patron...
      for j in range(patronLen): 
        # empiezo a recorrer el patron
        if cadena[i + j] != patronBuscar[j]:
          # no coinciden
          i += 1
          break
        if j == patronLen:
          # hay match como en tinder
          counter += 1
    else:
      # ir a siguiente palabra?
      i += 1
    print(i)
    i += 1   

  
  print(counter)


ingreso  = "qk qpAASDASDDAA AAAAAAERQREQREQRAaaAREWQRWERAAA"
contadorTiquetes(ingreso)

# como solucionar cuando no es una sola letra ???

#reto 3 


def contadorTiquetes(cadena):
  
  patronBuscar = "jua"

  #encontrar las longitudes
  sLen = len(cadena) ;  patronLen = len(patronBuscar) #2
  
  i = 0
  j = 0
  counter = 0 
  while i < sLen - patronLen :
    #print(patronBuscar[0] , cadena[i])
    if patronBuscar[0] == cadena[i]:
      
      # si primero coincide con primero.. verificar la siguiente letra i y j se desplazan
      for k in range(patronLen):  # recorrido interno
        #print(k)  # 0 1  esto se va a imprimir cada que encuentre una primer coincidencia 
        #print(patronBuscar[k] , cadena[i + k])
        if  patronBuscar[k] ==  cadena[i + k] and (k == patronLen - 1):
          # coincidencia total
          #print(patronBuscar[k] , cadena[i + k])
          counter += 1
          print("palabra encontrada")
      
  
    i += 1   
   
  print(counter)


ingreso  = "juan es un juanito bien juuanojuan"
contadorTiquetes(ingreso)

# hacer el contador par amultiples palabras 


def contadorSingleWord(busqueda,cadena): # ingresa la cadena y la palabra  a buscar 
  patronBuscar = busqueda
  sLen = len(cadena) ;  patronLen = len(patronBuscar) #2
  
  i = 0
  j = 0
  counter = 0 
  while i < sLen - patronLen :
    if patronBuscar[0] == cadena[i]:
      for k in range(patronLen):
        if  patronBuscar[k] ==  cadena[i + k] and (k == patronLen - 1):         
          counter += 1
          #print("palabra encontrada")
    i += 1   
   
  return counter   

def multipleWordRecurrence(cadena): 
  # ingresa un arreglo de la palabras qu evan a ser buscadas junto con la cadena de texto
  aBuscar = ['juan','jua','a','uan']
  cantidades = []
  for i in aBuscar:
    a = contadorSingleWord(i,cadena)
    print(i,a)
    cantidades.append(a)
    

  
ingreso  = "juan es un juanito bien juuanojuan"
multipleWordRecurrence(ingreso)

def countConsecutives(cadena):
  count = 1
  resultado = 1

  for i  in range(len(cadena)-1):
    #voy a comparar valor actual con el siguiente por eso va hasta -1
    if s[i]==s[i+1]:
      count +=1  # si son iguales cuenta aumenta ocntador
    else:
      count = 1 # se reinicia le contador
    


      
  return palabrasToSearch  

ingreso  = "aaaabbbbccdaa"
countConsecutives(ingreso)
# como los usuarios fueorn instruidos espacio genera la palabra a buscar y ademas crea la palabra

def saveWords(cadena):
  
  palabrasToSearch = []
  substring = []
  for i in range(len(cadena)):
    print( cadena[i] )
    if cadena[i] != " ":
      substring.append(cadena[i])
      #print(substring)
    elif cadena[i] == " ":
      palabrasToSearch.append(substring)
      substring = []

      
  return palabrasToSearch  



ingreso = "abs frt frt frt frt abs abs abs cd "
saveWords(ingreso)

# prueba integrando todo


def saveWords(cadena):
  palabrasToSearch = []
  substring = []
  for i in range(len(cadena)):
    if cadena[i] != " ":
      substring.append(cadena[i])
      #print(substring)
    elif cadena[i] == " ":
      palabrasToSearch.append(substring)
      substring = []  
  return palabrasToSearch  

def contaPalabras(listaPalabras):
  

  for i in range(len(listaPalabras)):
    if i == len(listaPalabras):
      print("verificar que hacer ocn ese ultimo elemnto")
    elif:
       count = 1
    palabraGoal = listaPalabras[i]
    print(palabraGoal)
    if listaPalabras[i] == listaPalabras[i+1]: 
      #si hay una palabra ocnsecutiva igual
      count += 1
   
    

  
  return count  



ingreso = "abs frt frt frt frt abs abs abs cd"
palabras = saveWords(ingreso)
cantidad = contaPalabras(palabras)

# prueba integrando todo


def saveWords(cadena):
  cadena = cadena + " " # anadir un espacio al final para busca rla totalidad
  palabrasToSearch = []
  substring = []
  for i in range(len(cadena)):
    #print( cadena[i] )
    if cadena[i] != " ":
      substring.append(cadena[i])
      
    elif cadena[i] == " ":
      palabrasToSearch.append(substring)
      substring = []
          
  return palabrasToSearch  

def contaPalabras(listaPalabras):
  
  listaPalabras.append(0) # anadir un cero por eso del overflow
  #print(listaPalabras)
  for i in range(len(listaPalabras)-1):
    count = 0
    palabraGoal = listaPalabras[i]
    
    if listaPalabras[i] == listaPalabras[i+1]: 
      #si hay una palabra ocnsecutiva igual
      count += 1
    if palabraGoal == listaPalabras[i]:
      # si la palbra siguiente en la lista e sigual a la que ya buscaba no deberia seguir ocntando
      count = 0
      palabraGoal = ' nada'
    print(palabraGoal)
 
  
 


ingreso = "abs frt frt frt frt abs abs abs cd"
palabras = saveWords(ingreso)
cantidad = contaPalabras(palabras)

# prueba integrando todo


def saveWords(cadena):
  cadena = cadena + " " # anadir un espacio al final para busca rla totalidad
  palabrasToSearch = []
  substring = []
  for i in range(len(cadena)):
    #print( cadena[i] )
    if cadena[i] != " ":
      substring.append(cadena[i])
      
    elif cadena[i] == " ":
      palabrasToSearch.append(substring)
      substring = []
          
  return palabrasToSearch  

def contaPalabras(listaPalabras):
  
  listaPalabras.append(0) # anadir un cero por eso del overflow
  print(listaPalabras)
  #print(listaPalabras)
  #palabraObjetivo = listaPalabras[0]

  palabrasObjetivo =[]
  conteoRecurrencia = []
  
  i = 0

  palabraObjetivo = listaPalabras[0]

  while i < len(listaPalabras)-1: #puedo hacer el menos 1 pq anadi un cero
    
    count = 1
    
       
    if listaPalabras[i] == palabraObjetivo:
     
      if  listaPalabras[i] == listaPalabras[i+1]: 
        
        print("entre")
        # si hay 2 palabras consecutivas anadir al contador
        count += 1
      conteoRecurrencia.append(count)
      if listaPalabras[i] != listaPalabras[i+1]: 
        # si no hay palbras consecutivas cambio la palabra objetivo
        
        conteoRecurrencia.append(count)
        count = 1

        palabrasObjetivo.append(palabrasObjetivo)  # anadir a la lista  la palabra que va a ser la meta 
        palabraObjetivo = " "
      

    
    i += 1 
   
   



ingreso = "abs abs frt frt frt frt abs abs abs cd"
palabras = saveWords(ingreso)
cantidad = contaPalabras(palabras)

# prueba integrando todo ... repensando en iterar hacia atras


def saveWords(cadena):
  cadena = cadena + " " # anadir un espacio al final para busca rla totalidad
  palabrasToSearch = []
  substring = []
  for i in range(len(cadena)):
    #print( cadena[i] )
    if cadena[i] != " ":
      substring.append(cadena[i])
      
    elif cadena[i] == " ":
      palabrasToSearch.append(substring)
      substring = []
          
  return palabrasToSearch  

def contaPalabras(listaPalabras):
  
  listaPalabras.append(0) # anadir un cero por eso del overflow
  print(listaPalabras)
  #print(listaPalabras)
  #palabraObjetivo = listaPalabras[0]

  palabrasObjetivo =[]
  conteoRecurrencia = []
  
  i = 0
  count = 1
  

  secuenciaActual = listaPalabras[0]
  secuenciaAnterior = " "

  while i < len(listaPalabras)-1:
    secuenciaActual = listaPalabras[i]
    if secuenciaAnterior == listaPalabras[i] and i >=1:           
      # arranca en i = 1 asimilando que ya pusimo en el contador el primer item
      count += 1
    else:
      count = 1
    
 
    print(count,secuenciaActual)
    secuenciaAnterior = listaPalabras[i]
    

    i += 1 
   
   



ingreso = "JB04 JB04 JB04 LC89779 JN04 JN04"
palabras = saveWords(ingreso)
cantidad = contaPalabras(palabras)

# removiendo duplicados 


def saveWords(cadena):
  cadena = cadena + " " # anadir un espacio al final para busca rla totalidad
  palabrasToSearch = []
  substring = []
  for i in range(len(cadena)):
    #print( cadena[i] )
    if cadena[i] != " ":
      substring.append(cadena[i])
      
    elif cadena[i] == " ":
      palabrasToSearch.append(substring)
      substring = []
          
  return palabrasToSearch  

def contaPalabras(listaPalabras):
  
  listaPalabras.append(0) # anadir un cero por eso del overflow
  print(listaPalabras)
  #print(listaPalabras)
  #palabraObjetivo = listaPalabras[0]

  palabrasObjetivo =[]
  conteoRecurrencia = []
  
  i = 0
  count = 1
  maximoContador = count
  maximoCaracter = " "

  secuenciaActual = listaPalabras[0]
  secuenciaAnterior = " "

  while i < len(listaPalabras)-1:
    secuenciaActual = listaPalabras[i]
    if secuenciaAnterior == listaPalabras[i] and i >=1:       
      # arranca en i = 1 asimilando que ya pusimo en el contador el primer item
      count += 1
    else:
      count = 1
    
    #objetivo almacena runa lista de los maximos contadores
    
    if count > maximoContador:
        maximoContador = count
        maximoCaracter = listaPalabras[i]
    if listaPalabras[i] != listaPalabras[i+1]:
          maximoCaracter = listaPalabras[i+1]
          maximoContador = 1
        

    print(maximoContador,maximoCaracter)
    #print(count,secuenciaActual)
    secuenciaAnterior = listaPalabras[i]
    

    i += 1 
   
   



ingreso = "JB04 JB04 JB04 LC89779 JN04 JN04"
palabras = saveWords(ingreso)
cantidad = contaPalabras(palabras)

# y si lo guardo en un diccionario y elimino los reptidos y dejo el valor asociado mayor 

# removiendo duplicados 


def saveWords(cadena):
  cadena = cadena + " " # anadir un espacio al final para busca rla totalidad
  palabrasToSearch = []
  substring = []
  for i in range(len(cadena)):
    #print( cadena[i] )
    if cadena[i] != " ":
      substring.append(cadena[i])
      
    elif cadena[i] == " ":
      palabrasToSearch.append(substring)
      substring = []
          
  return palabrasToSearch  

def contarPalabras(listaPalabras):
  
  listaPalabras.append(0) # anadir un cero por eso del overflow
  print(listaPalabras)
  #print(listaPalabras)
  #palabraObjetivo = listaPalabras[0]

  palabrasObjetivo =[]
  conteoRecurrencia = []
  
  i = 0
  count = 1
  maximoContador = count
  maximoCaracter = " "

  secuenciaActual = listaPalabras[0]
  secuenciaAnterior = " "

  palabrasObjetivo.append(secuenciaActual)



  while i < len(listaPalabras)-1:
    secuenciaActual = listaPalabras[i]
    if secuenciaAnterior == listaPalabras[i] :       
      count += 1
    else:
      count = 1
    
    #objetivo almacenarb una lista de los maximos contadores
    #print(listaPalabras[i],listaPalabras[i+1])
    #print(count,secuenciaActual)
    if count >= maximoContador:     
      maximoContador = count
      maximoCaracter = listaPalabras[i]
      #print(maximoContador)
      

    #print(maximoContador,maximoCaracter)
    #print(count,secuenciaActual)

    if listaPalabras[i] != listaPalabras[i+1]: # si el siguiente elemento no es igual reinicio el contador y el maximo elemento
      #print(maximoContador)
      conteoRecurrencia.append(maximoContador)
      count = 1
      maximoContador = count
      maximoCaracter = listaPalabras[i+1]  # re asigno cual va ser el maximo caracter como un spoiler
      palabrasObjetivo.append(maximoCaracter) # guardo los caracteres los cuales llegaorn a ser los mayores y los bjetivos de la buqued apar ale conteo
    

    #print(maximoContador,maximoCaracter)
    secuenciaAnterior = listaPalabras[i]
    

    i += 1 
  print(palabrasObjetivo[:-1],conteoRecurrencia)
   



ingreso = "JB04 JB04 JB04 JB04 LC89779 JN04 JN04 JB04"
palabras = saveWords(ingreso)
cantidad = contarPalabras(palabras)



# Yacasito ...
def saveWords(cadena):
  cadena = cadena + " " # anadir un espacio al final para busca rla totalidad
  palabrasToSearch = []
  substring = []
  for i in range(len(cadena)):
    #print( cadena[i] )
    if cadena[i] != " ":
      substring.append(cadena[i])
      
    elif cadena[i] == " ":
      palabrasToSearch.append(substring)
      substring = []
          
  return palabrasToSearch  




def contarPalabras(listaPalabras):
  
  listaPalabras.append(0) # anadir un cero por eso del overflow
  palabrasObjetivo =[]
  conteoRecurrencia = []
  
  i = 0
  count = 1
  maximoContador = count
  maximoCaracter = " "

  secuenciaActual = listaPalabras[0]
  secuenciaAnterior = " "

  palabrasObjetivo.append(secuenciaActual)



  while i < len(listaPalabras)-1:
    secuenciaActual = listaPalabras[i]
    if secuenciaAnterior == listaPalabras[i] :       
      count += 1
    else:
      count = 1
    
    if count >= maximoContador:     
      maximoContador = count
      maximoCaracter = listaPalabras[i]
      

    if listaPalabras[i] != listaPalabras[i+1]: # si el siguiente elemento no es igual reinicio el contador y el maximo elemento
      conteoRecurrencia.append(maximoContador)
      count = 1
      maximoContador = count
      maximoCaracter = listaPalabras[i+1]  # re asigno cual va ser el maximo caracter como un spoiler
      palabrasObjetivo.append(maximoCaracter) # guardo los caracteres los cuales llegaorn a ser los mayores y los bjetivos de la buqued apar ale conteo
    
    secuenciaAnterior = listaPalabras[i]
    
    i += 1 
  
  return list(palabrasObjetivo[:-1]) , conteoRecurrencia
   
def resultadoEnString(cadena , cantidad):
  megaString = " "
  for i in cadena:
    
    subString = ''.join([str(elem) for elem in i])
    subString = subString + " "
    #print(subString)
    megaString += subString
  #print(megaString) 
  megaString = megaString.strip() 

  numeros = ' '.join([str(elem) for elem in cantidad])

  return megaString,numeros
  
  
     
  



ingreso = "abs frt frt frt frt abs abs abs cd"
palabras = saveWords(ingreso)
lista , listaCantidad = contarPalabras(palabras)

a, b = resultadoEnString(lista,listaCantidad)
print(a) ; print(b)